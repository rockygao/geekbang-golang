# 1、总结几种 socket 粘包的解包方式：fix length/delimiter based/length field based frame decoder。尝试举例其应用。

初次听到粘包这个词，什么是粘包？触及到了知识盲区，查阅了一些资料

## socket
它是我们所谓的“长链接”，它是一个套接字 实际上我觉得它是支持传输协议的的一个基本的单元，它支持tcp/ip 协议 也支持udp协议。

* TCP/IP 协议簇建立了互联网中通信协议的概念模型，该协议簇中的两个主要协议就是 TCP 和 IP 协议。TCP/ IP 协议簇中的 TCP 协议能够保证数据段（Segment）的可靠性和顺序，有了可靠的传输层协议之后，应用层协议就可以直接使用 TCP 协议传输数据，不在需要关心数据段的丢失和重复问题。
* IP 协议解决了数据包（Packet）的路由和传输，上层的 TCP 协议不再关注路由和寻址，那么 TCP 协议解决的是传输的可靠性和顺序问题，上层不需要关心数据能否传输到目标进程，只要写入 TCP 协议的缓冲区的数据，协议栈几乎都能保证数据的送达。
* 当应用层协议使用 TCP 协议传输数据时，TCP 协议可能会将应用层发送的数据分成多个包依次发送，而数据的接收方收到的数据段可能有多个『应用层数据包』组成，所以当应用层从 TCP 缓冲区中读取数据时发现粘连的数据包时，需要对收到的数据进行拆分。

## 何为粘包？

粘包：多个数据包被连续存储于连续的缓存中，在对数据包进行读取时由于无法确定发生方的发送边界，而采用某一估测值大小来进行数据读出，若双方的size不一致时就会使指发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。
### 出现粘包的原因
出现粘包现象的原因是多方面的，它既可能由发送方造成，也可能由接收方造成。

#### 1、先说简单的接收方原因
接收方引起的粘包是由于接收方用户进程不及时接收数据，从而导致粘包现象。这是因为接收方先把收到的数据放在系统接收缓冲区，用户进程从该缓冲区取数据，若下一包数据到达时前一包数据尚未被用户进程取走，则下一包数据放到系统接收缓冲区时就接到前一包数据之后，而用户进程根据预先设定的缓冲区大小从系统接收缓冲区取数据，这样就一次取到了多包数据。
#### 2、再说由发送导致的粘包, 这个比较有意思
粘包并不是 TCP 协议造成的，它的出现是因为应用层协议设计者对 TCP 协议的错误理解，忽略了 TCP 协议的定义并且缺乏设计应用层协议的经验。我们将从 TCP 协议以及应用层协议出发，分析我们经常提到的 TCP 协议中的粘包是如何发生的：

* TCP 协议是面向字节流的协议，它可能会组合或者拆分应用层协议的数据；
* 应用层协议的没有定义消息的边界导致数据的接收方无法拼接数据；

TCP 协议是面向连接的、可靠的、基于字节流的传输层通信协议，应用层交给 TCP 协议的数据并不会以消息为单位向目的主机传输，这些数据在某些情况下会被组合成一个数据段发送给目标的主机。



## 解包方式
### fix length
按照指定的长度来对消息进行分隔解包，例如MTU（数据链路层最大传输单元）

### delimiter based
按照特殊分隔符来对消息进行分隔解包，例如HTTP 是按照特殊分隔符分隔

### length field based frame decoder
LengthFieldBasedFrameDecoder是一个基于长度解码器, 它是Netty提供的4个解码器中使用最广泛的一个解码器, RocketMQ中就是基于这个解码器进行解码消息的


# 2、实现一个从 socket connection 中解码出 goim 协议的解码器。

